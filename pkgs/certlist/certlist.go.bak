package certlist

import (
    "os"
    "fmt"
)

const (
    moklist := "/sys/firmware/efi/mok-variables/MokListRT"
    sigTypeOffset := 0
    sigListSizeOffset := 16
    headerSizeOffset := 20
    sigSizeOffset := 24
    sigOwnerOffset := 28
    paddingOffset := 44
    certOffset := 45
)

type MokListHeader struct {
    Sigtype [16]bytes
    SigListSize uint32
    HeaderSize uint32
    SigSize uint32
    SigOwner [16]bytes
    Padding byte
}

type MokListEntry struct {
    Header  MokListHeader
    Cert    []byte
}


type certlist struct {
    Certs []*cert
}

func NewCertList() *certlist {
    return *certlist{}
}

func NewCertListFromMOKDB() (*certlist, error) {
	buffer, err := os.ReadFile(moklist)
	if err != nil {
		return nil, fmt.Errorf("Failed to read cert %s: %s\n", filename, err)
	}
    cl := certlist{}
    offset := 0
    moklen := len(buffer)
    for offset < moklen {
        header := MokListHeader{}

       	buf := bytes.NewReader(buffer[offset])
        err := binary.Read(buf, binary.NativeEndian, &header)

        entry := MokListEntry{
            Header=header,
            cert = buffer[offset + certOffset : offset + (header.sigSize - 17)]
        }
 
        c := cert {}
        c.Filename = moklist
        c.Cert = cert
        cl = append(cl, c)

        offset += (certOffset + header.sigSize - 17 )
    }


    return cl, nil
}

func (c *certlist) AddCert(filename string) error {

    return nil
}



type cert struct {
    Filename string
    ParsedCert x509.Certificate        
    Sigtype [16]bytes
    SigListSize uint32
    HeaderSize uint32
    SigSize uint32
    SigOwner [16]bytes
    Padding byte
    Cert []bytes
}

func NewCertFromFile(filename) *cert {
	buffer, err := os.ReadFile(filename) // just pass the file name
	if err != nil {
		return nil, fmt.Errorf("Failed to read cert %s: %s\n", filename, err)
	}


}

func NewCertFromBuffer(buffer []byte) (*cert, error) {
    
	pubCert, err := x509.ParseCertificate(buffer)
	if err != nil {
		return false, fmt.Errorf("failed to parse certificate %s\n", err)
	}

}


func (c *cert) checkSig(buffer []byte) (bool, error) {




func checkSig(buffer []byte, cert []byte) (bool, error) {

	hash := sha256.Sum256(buffer)

	pubCert, err := x509.ParseCertificate(cert)
	if err != nil {
		fmt.Printf("invalid public key %s\n", err)
		return false, fmt.Errorf("invalid public key %s\n", err)
	}

	pubKey := pubCert.PublicKey.(*rsa.PublicKey)
	if err != nil {
		fmt.Printf("invalid public key %s\n", err)
		return false, fmt.Errorf("invalid public key %s\n", err)
	}

	sigDigest, err := s.getDigest()
	if err != nil {
		return false, err
	}

	err = rsa.VerifyPKCS1v15(pubKey, crypto.SHA256, hash[:], *sigDigest)
	if err != nil {
		fmt.Printf("  signature not verified\n")
		return false, nil
	}


	fmt.Printf("  signature verified\n\tsubject: %s\n\tserial: %s\n", pubCert.Subject.ToRDNSequence(), pubCert.SerialNumber)

	return true, nil
}
*/
